
	<!DOCTYPE html>
	<html lang="es">
	<head>
		<title>Metodos de ordenamiento</title>
		
	</head>
	<body>
	<p> Metodos de ordenamiento
	Debido a que las estructuras de datos son utilizadas para almacenar información, para poder recuperar esa información de manera eficiente es deseable que aquella esté ordenada. Existen varios métodos para ordenar las diferentes estructuras de datos básicas.
En general los métodos de ordenamiento no son utilizados con frecuencia, en algunos casos sólo una vez. Hay métodos muy simples de implementar que son útiles en los casos en dónde el número de elementos a ordenar no es muy grande (ej., menos de 500 elementos). Por otro lado hay métodos sofisticados, más difíciles de implementar pero que son más eficientes en cuestión de tiempo de ejecución.

Los métodos sencillos por lo general requieren de aproximadamente n x n pasos para ordenar  elementos.

Los métodos simples son 
•	insertion sort (o por inserción directa) selection sort, bubble sort, y shellsort, en dónde el último es una extensión al insertion sort, siendo más rápido. 
Los métodos más complejos son 
•	Quicksort, el heap sort, radix y address-calculation sort. El ordenar un grupo de datos significa mover los datos o sus referencias para que queden en una secuencia tal que represente un orden, el cual puede ser numérico, alfabético o incluso alfanumérico, ascendente o descendente.

TIPOS DE ORDENAMIENTO
ORDENAMIENTO INTERNO Se lleva a cabo completamente en memoria principal. Todos los objetos que se ordenan caben en la memoria principal de la computadora F ORDENAMIENTO EXTERNO No cabe toda la información en memoria principal y es necesario ocupar memoria secundaria. El ordenamiento ocurre transfiriendo bloques de información a memoria principal en donde se ordena el bloque y este es regresado, ya ordenado, a memoria secundaria


ORDENAMIENTO DE BURBUJA

La Ordenación de burbuja (Bubble Sort en inglés) es un sencillo algoritmo de ordenamiento. Funciona revisando cada elemento de la lista que va a ser ordenada con el siguiente, intercambiándolos de posición si están en el orden equivocado. Es necesario revisar varias veces toda la lista hasta que no se necesiten más intercambios, lo cual significa que la lista está ordenada. Este algoritmo obtiene su nombre de la forma con la que suben por la lista los elementos durante los intercambios, como si fueran pequeñas "burbujas". También es conocido como el método del intercambio directo. Dado que solo usa comparaciones para operar elementos, se lo considera un algoritmo de comparación, siendo el más sencillo de implementar.

 

BURBUJA 
#include<stdio.h> 
#include<conio.h> 
int a[3]={3,2,1}; 
int i,j,aux,n=3; 
void main(){ 
clrscr(); 
for(i=0;i<=n;i++){ 
for(j=0;j<n-1;j++){ 
if(a[j]>a[j+1]){ 
aux=a[j]; 
a[j]=a[j+1]; 
a[j+1]=aux; 
} 
} 
} 
for(i=0;i<3;i++) 
{ 
printf("%d",a); 
} 
getch(); 
}



ORDENAMIENTO SHELL
 El ordenamiento Shell (Shell sort en inglés) es un algoritmo de ordenamiento. El método se denomina Shell en honor de su inventor Donald Shell. Su implementación original, requiere O(n2) comparaciones e intercambios en el peor caso. Un cambio menor presentado en el libro de V. Pratt produce una implementación con un rendimiento de O(n log2 n) en el peor caso. Esto es mejor que las O(n2) comparaciones requeridas por algoritmos simples pero peor que el óptimo O(n log n). Aunque es fácil desarrollar un sentido intuitivo de cómo funciona este algoritmo, es muy difícil analizar su tiempo de ejecución. El algoritmo Shell sort mejora el ordenamiento por inserción comparando elementos separados por un espacio de varias posiciones. Esto permite que un elemento haga "pasos más grandes" hacia su posición esperada. Los pasos múltiples sobre los datos se hacen con tamaños de espacio cada vez más pequeños. El último paso del Shell sort es un simple ordenamiento por inserción, pero para entonces, ya está garantizado que los datos del vector están casi ordenados.  
 


SHELL 
#include<stdio.h> 
#include<conio.h> 
int a[5]; 
int n=5; 
void main() 
{ 
int inter=(n/2),i=0,j=0,k=0,aux; 
clrscr(); 
for (i=0; i<5; i++) 
{ 
printf("INSERTA UN VALOR DEL INDICE %d", i); 
scanf("%d",& a); 
} 
while(inter>0){ 
for(i=inter;i<n;i++) 
{ 
j=i-inter; 
while(j>=0) { 
k=j+inter; 
if(a[j]<=a[k]){ 
j--; 
} 
else{ 
aux=a[j]; 
a[j]=a[k]; 
a[k]=aux; 
j=j-inter; 
} 
} 
} 
inter=inter/2; 
} 
for(i=0;i<5;i++) 
{ 
printf("%d n",a); 
getch(); 
} 
}    



ORDENAMIENTO POR INSERCION

El ordenamiento por inserción (insertion sort en inglés) es una manera muy natural de ordenar para un ser humano, y puede usarse fácilmente para ordenar un mazo de cartas numeradas en forma arbitraria. Requiere O(n²) operaciones para ordenar una lista de n elementos. Inicialmente se tiene un solo elemento, que obviamente es un conjunto ordenado. Después, cuando hay k elementos ordenados de menor a mayor, se toma el elemento k+1 y se compara con todos los elementos ya ordenados, deteniéndose cuando se encuentra un elemento menor (todos los elementos mayores han sido desplazados una posición a la derecha) o cuando ya no se encuentran elementos (todos los elementos fueron desplazados y este es el más pequeño). En este punto se inserta el elemento k+1 debiendo desplazarse los demás elementos.
 


INSERCIÓN 

#include<stdio.h> 
#include<conio.h> 
int a[4]={4,1,7,2}; 
int n=4; 
int i,j,aux; 
void main(){ 
clrscr(); 
for(i=1;i<n;i++) 
{ 
j=i; 
aux=a; 
while(j>0 && aux<a[j-1]) 
{ 
a[j]=a[j-1]; 
j--; 
} 
a[j]=aux; 
} 
for(i=0;i<4;i++) 
{ 
printf("%d",a); 
} 
getch(); 
} 

ORDENAMIENTO RÁPIDO (QUICKSORT)
El ordenamiento rápido (Quicksort en inglés) es un algoritmo basado en la técnica de divide y vencerás, que permite, en promedio, ordenar n elementos en un tiempo proporcional a n log n. Esta es la técnica de ordenamiento más rápida conocida. Fue desarrollada por C. Antony R. Hoare en 1960. El algoritmo original es recursivo, pero se utilizan versiones iterativas para mejorar su rendimiento (los algoritmos recursivos son en general más lentos que los iterativos, y consumen más recursos).

 


 ORDENAMIENTO POR SELECCION

El ordenamiento por selección (Selection Sort en inglés) es un algoritmo de ordenamiento que requiere O operaciones para ordenar una lista de n elementos.
Su funcionamiento es el siguiente:


•	Buscar el mínimo elemento de la lista
•	Intercambiarlo con el primero
•	Buscar el mínimo en el resto de la lista
•	Intercambiarlo con el segundo
 


para i=1 hasta n-1
    minimo = i;
    para j=i+1 hasta n
        si lista[j] < lista[minimo] entonces
            minimo = j /* (!) */
        fin si
    fin para
    intercambiar(lista[i], lista[minimo])
fin para 

SELECCION 
#include<stdio.h> 
#include<conio.h> 
int x[4]={1,4,8,6}; 
int n=4,j=0,i=0; 
int temp=0,minimo=0; 
void main(){ 
clrscr(); 
for(i=0;i<n-1;i++) 
{ 
minimo=i; 
for(j=i+1;j<n;j++) 
{ 
if(x[minimo] > x[j]) 
{ 
minimo=j; 
} 
} 
temp=x[minimo]; 
x[minimo]=x; 
x=temp; 
} 
for(i=0;i<n;i++) 
{ 
printf("%d",x); 
} 
getch(); 
}
REFERENCIA BIBLIOGRÁFICA

•	Unknowm (2013).Programación I :Métodos de ordenamiento: http://iutprogramacion.blogspot.com/2013/02/metodos-de-ordenamiento.html.

•	Arturo Diaz Pérez () Análisis y complejidad de algoritmo: Métodos de ordenamiento: https://delta.cs.cinvestav.mx/~adiaz/anadis/Sorting2.pdf.

•	Copyright (2010-2011) Ordenamiento-Métodos:
https://paginadec.webcindario.com/old/ordenamiento-metodos.html.

</p>
	</body>
	</html>